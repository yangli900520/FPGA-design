// -------------------------------------------------------------
// 
// File Name: /home/yangli18/Documents/yangzai/PFC/qr_simulink/HDL/qr10/fourxfour_designfxdpt_givens/Givens_Boundary_Cell3.v
// Created: 2019-10-01 15:17:02
// 
// Generated by MATLAB 9.5 and HDL Coder 3.13
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Givens_Boundary_Cell3
// Source Path: fourxfour_designfxdpt_givens/fourxfour_designfxdpt/Givens_Boundary_Cell3
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Givens_Boundary_Cell3
          (clk,
           reset,
           enb,
           enb_2_1_0,
           uin_r,
           uin_i,
           En_bp,
           Bin_r,
           Bin_i,
           Enable,
           c_out,
           sout_r,
           sout_i,
           rout_r,
           rout_i);


  input   clk;
  input   reset;
  input   enb;
  input   enb_2_1_0;
  input   signed [23:0] uin_r;  // sfix24_En14
  input   signed [23:0] uin_i;  // sfix24_En14
  input   En_bp;
  input   signed [23:0] Bin_r;  // sfix24_En14
  input   signed [23:0] Bin_i;  // sfix24_En14
  input   Enable;
  output  signed [23:0] c_out;  // sfix24_En14
  output  signed [23:0] sout_r;  // sfix24_En14
  output  signed [23:0] sout_i;  // sfix24_En14
  output  signed [23:0] rout_r;  // sfix24_En14
  output  signed [23:0] rout_i;  // sfix24_En14


  wire signed [47:0] Product3_out1;  // sfix48_En28
  wire signed [47:0] Product4_out1;  // sfix48_En28
  wire signed [48:0] Add_add_cast;  // sfix49_En28
  wire signed [48:0] Add_add_cast_1;  // sfix49_En28
  wire signed [48:0] Add_out1;  // sfix49_En28
  wire enb_gated;
  wire [48:0] Sqrt_out1;  // ufix49_En28
  wire signed [23:0] Data_Type_Conversion3_out1;  // sfix24_En14
  wire signed [47:0] Product8_out1;  // sfix48_En28
  reg signed [47:0] Delay1_out1;  // sfix48_En28
  wire signed [49:0] Add1_add_cast;  // sfix50_En28
  wire signed [49:0] Add1_add_cast_1;  // sfix50_En28
  wire signed [49:0] Add1_add_temp;  // sfix50_En28
  wire [48:0] Add1_out1;  // ufix49_En28
  wire enb_gated_1;
  reg [48:0] Delay4_reg [0:4];  // ufix49 [5]
  wire [48:0] Delay4_reg_next [0:4];  // ufix49_En28 [5]
  wire [48:0] Delay4_out1;  // ufix49_En28
  wire [48:0] HDL_Reciprocal_out1;  // ufix49_En20
  wire [97:0] Product1_out1;  // ufix98_En48
  wire signed [23:0] Data_Type_Conversion4_out1;  // sfix24_En14
  wire enb_gated_2;
  reg signed [23:0] Delay3_reg [0:3];  // sfix24 [4]
  wire signed [23:0] Delay3_reg_next [0:3];  // sfix24_En14 [4]
  wire signed [23:0] Delay3_out1;  // sfix24_En14
  wire signed [49:0] Product5_cast;  // sfix50_En20
  wire signed [73:0] Product5_mul_temp;  // sfix74_En34
  wire signed [72:0] Product5_out1;  // sfix73_En34
  wire signed [23:0] Data_Type_Conversion7_out1;  // sfix24_En14
  wire enb_gated_3;
  reg signed [23:0] Delay2_reg [0:3];  // sfix24 [4]
  wire signed [23:0] Delay2_reg_next [0:3];  // sfix24_En14 [4]
  wire signed [23:0] Delay2_out1;  // sfix24_En14
  wire signed [49:0] Product2_cast;  // sfix50_En20
  wire signed [73:0] Product2_mul_temp;  // sfix74_En34
  wire signed [72:0] Product2_out1;  // sfix73_En34
  wire signed [23:0] Data_Type_Conversion5_out1;  // sfix24_En14
  wire signed [72:0] Sqrt_out1_dtc;  // sfix73_En34
  wire signed [49:0] Product6_cast;  // sfix50_En20
  wire signed [73:0] Product6_mul_temp;  // sfix74_En34
  wire signed [72:0] Product6_out1;  // sfix73_En34
  wire signed [72:0] Switch_out1;  // sfix73_En34
  wire enb_gated_4;
  reg signed [72:0] Delay5_reg [0:3];  // sfix73 [4]
  wire signed [72:0] Delay5_reg_next [0:3];  // sfix73_En34 [4]
  wire signed [72:0] Delay5_out1;  // sfix73_En34
  wire signed [23:0] Data_Type_Conversion2_out1;  // sfix24_En14
  wire signed [23:0] Constant_out1;  // sfix24_En14
  wire signed [72:0] Constant_out1_dtc;  // sfix73_En34
  wire signed [49:0] Product7_cast;  // sfix50_En20
  wire signed [73:0] Product7_mul_temp;  // sfix74_En34
  wire signed [72:0] Product7_out1;  // sfix73_En34
  wire signed [72:0] Switch1_out1;  // sfix73_En34
  wire enb_gated_5;
  reg signed [72:0] Delay6_reg [0:3];  // sfix73 [4]
  wire signed [72:0] Delay6_reg_next [0:3];  // sfix73_En34 [4]
  wire signed [72:0] Delay6_out1;  // sfix73_En34
  wire signed [23:0] Data_Type_Conversion8_out1;  // sfix24_En14


  assign Product3_out1 = uin_r * uin_r;



  assign Product4_out1 = uin_i * uin_i;



  assign Add_add_cast = {Product3_out1[47], Product3_out1};
  assign Add_add_cast_1 = {Product4_out1[47], Product4_out1};
  assign Add_out1 = Add_add_cast + Add_add_cast_1;



  assign enb_gated = Enable && enb;

  assign Data_Type_Conversion3_out1 = $signed(Sqrt_out1[37:14]);



  assign Product8_out1 = Data_Type_Conversion3_out1 * Data_Type_Conversion3_out1;



  always @(posedge clk)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 48'sh000000000000;
      end
      else begin
        if (enb_gated) begin
          Delay1_out1 <= Product8_out1;
        end
      end
    end



  assign Add1_add_cast = {Add_out1[48], Add_out1};
  assign Add1_add_cast_1 = {{2{Delay1_out1[47]}}, Delay1_out1};
  assign Add1_add_temp = Add1_add_cast + Add1_add_cast_1;
  assign Add1_out1 = Add1_add_temp[48:0];



  Sqrt_block1 u_Sqrt (.din(Add1_out1),  // ufix49_En28
                      .dout(Sqrt_out1)  // ufix49_En28
                      );




  /*sqrt_nonstore u_Sqrt_2
              (.clk(clk),
               .rst(reset),
               .din(Add1_out1),  // ufix49_En28
               .dout(Sqrt_out1)  // ufix49_En28
               );*/






  assign enb_gated_1 = Enable && enb;

  always @(posedge clk)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg[0] <= 49'h0000000000000;
        Delay4_reg[1] <= 49'h0000000000000;
        Delay4_reg[2] <= 49'h0000000000000;
        Delay4_reg[3] <= 49'h0000000000000;
        Delay4_reg[4] <= 49'h0000000000000;
      end
      else begin
        if (enb_gated_1) begin
          Delay4_reg[0] <= Delay4_reg_next[0];
          Delay4_reg[1] <= Delay4_reg_next[1];
          Delay4_reg[2] <= Delay4_reg_next[2];
          Delay4_reg[3] <= Delay4_reg_next[3];
          Delay4_reg[4] <= Delay4_reg_next[4];
        end
      end
    end

  assign Delay4_out1 = Delay4_reg[4];
  assign Delay4_reg_next[0] = Sqrt_out1;
  assign Delay4_reg_next[1] = Delay4_reg[0];
  assign Delay4_reg_next[2] = Delay4_reg[1];
  assign Delay4_reg_next[3] = Delay4_reg[2];
  assign Delay4_reg_next[4] = Delay4_reg[3];



  HDL_Reciprocal_block1 u_HDL_Reciprocal (.clk(clk),
                                          .reset(reset),
                                          .enb(enb),
                                          .enb_2_1_0(enb_2_1_0),
                                          .din(Sqrt_out1),  // ufix49_En28
                                          .dout(HDL_Reciprocal_out1)  // ufix49_En20
                                          );

  assign Product1_out1 = Delay4_out1 * HDL_Reciprocal_out1;



  assign Data_Type_Conversion4_out1 = $signed(Product1_out1[57:34]);



  assign c_out = Data_Type_Conversion4_out1;

  assign enb_gated_2 = Enable && enb;

  always @(posedge clk)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_reg[0] <= 24'sb000000000000000000000000;
        Delay3_reg[1] <= 24'sb000000000000000000000000;
        Delay3_reg[2] <= 24'sb000000000000000000000000;
        Delay3_reg[3] <= 24'sb000000000000000000000000;
      end
      else begin
        if (enb_gated_2) begin
          Delay3_reg[0] <= Delay3_reg_next[0];
          Delay3_reg[1] <= Delay3_reg_next[1];
          Delay3_reg[2] <= Delay3_reg_next[2];
          Delay3_reg[3] <= Delay3_reg_next[3];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[3];
  assign Delay3_reg_next[0] = uin_r;
  assign Delay3_reg_next[1] = Delay3_reg[0];
  assign Delay3_reg_next[2] = Delay3_reg[1];
  assign Delay3_reg_next[3] = Delay3_reg[2];



  assign Product5_cast = {1'b0, HDL_Reciprocal_out1};
  assign Product5_mul_temp = Product5_cast * Delay3_out1;
  assign Product5_out1 = Product5_mul_temp[72:0];



  assign Data_Type_Conversion7_out1 = Product5_out1[43:20];



  assign sout_r = Data_Type_Conversion7_out1;

  assign enb_gated_3 = Enable && enb;

  always @(posedge clk)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg[0] <= 24'sb000000000000000000000000;
        Delay2_reg[1] <= 24'sb000000000000000000000000;
        Delay2_reg[2] <= 24'sb000000000000000000000000;
        Delay2_reg[3] <= 24'sb000000000000000000000000;
      end
      else begin
        if (enb_gated_3) begin
          Delay2_reg[0] <= Delay2_reg_next[0];
          Delay2_reg[1] <= Delay2_reg_next[1];
          Delay2_reg[2] <= Delay2_reg_next[2];
          Delay2_reg[3] <= Delay2_reg_next[3];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[3];
  assign Delay2_reg_next[0] = uin_i;
  assign Delay2_reg_next[1] = Delay2_reg[0];
  assign Delay2_reg_next[2] = Delay2_reg[1];
  assign Delay2_reg_next[3] = Delay2_reg[2];



  assign Product2_cast = {1'b0, HDL_Reciprocal_out1};
  assign Product2_mul_temp = Product2_cast * Delay2_out1;
  assign Product2_out1 = Product2_mul_temp[72:0];



  assign Data_Type_Conversion5_out1 = Product2_out1[43:20];



  assign sout_i = Data_Type_Conversion5_out1;

  assign Sqrt_out1_dtc = {18'b0, {Sqrt_out1, 6'b000000}};



  assign Product6_cast = {1'b0, HDL_Reciprocal_out1};
  assign Product6_mul_temp = Bin_r * Product6_cast;
  assign Product6_out1 = Product6_mul_temp[72:0];



  assign Switch_out1 = (En_bp == 1'b0 ? Sqrt_out1_dtc :
              Product6_out1);



  assign enb_gated_4 = Enable && enb;

  always @(posedge clk)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_reg[0] <= 73'sh0000000000000000000;
        Delay5_reg[1] <= 73'sh0000000000000000000;
        Delay5_reg[2] <= 73'sh0000000000000000000;
        Delay5_reg[3] <= 73'sh0000000000000000000;
      end
      else begin
        if (enb_gated_4) begin
          Delay5_reg[0] <= Delay5_reg_next[0];
          Delay5_reg[1] <= Delay5_reg_next[1];
          Delay5_reg[2] <= Delay5_reg_next[2];
          Delay5_reg[3] <= Delay5_reg_next[3];
        end
      end
    end

  assign Delay5_out1 = Delay5_reg[3];
  assign Delay5_reg_next[0] = Switch_out1;
  assign Delay5_reg_next[1] = Delay5_reg[0];
  assign Delay5_reg_next[2] = Delay5_reg[1];
  assign Delay5_reg_next[3] = Delay5_reg[2];



  assign Data_Type_Conversion2_out1 = Delay5_out1[43:20];



  assign rout_r = Data_Type_Conversion2_out1;

  assign Constant_out1 = 24'sb000000000000000000000000;



  assign Constant_out1_dtc = {{29{Constant_out1[23]}}, {Constant_out1, 20'b00000000000000000000}};



  assign Product7_cast = {1'b0, HDL_Reciprocal_out1};
  assign Product7_mul_temp = Bin_i * Product7_cast;
  assign Product7_out1 = Product7_mul_temp[72:0];



  assign Switch1_out1 = (En_bp == 1'b0 ? Constant_out1_dtc :
              Product7_out1);



  assign enb_gated_5 = Enable && enb;

  always @(posedge clk)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_reg[0] <= 73'sh0000000000000000000;
        Delay6_reg[1] <= 73'sh0000000000000000000;
        Delay6_reg[2] <= 73'sh0000000000000000000;
        Delay6_reg[3] <= 73'sh0000000000000000000;
      end
      else begin
        if (enb_gated_5) begin
          Delay6_reg[0] <= Delay6_reg_next[0];
          Delay6_reg[1] <= Delay6_reg_next[1];
          Delay6_reg[2] <= Delay6_reg_next[2];
          Delay6_reg[3] <= Delay6_reg_next[3];
        end
      end
    end

  assign Delay6_out1 = Delay6_reg[3];
  assign Delay6_reg_next[0] = Switch1_out1;
  assign Delay6_reg_next[1] = Delay6_reg[0];
  assign Delay6_reg_next[2] = Delay6_reg[1];
  assign Delay6_reg_next[3] = Delay6_reg[2];



  assign Data_Type_Conversion8_out1 = Delay6_out1[43:20];



  assign rout_i = Data_Type_Conversion8_out1;

endmodule  // Givens_Boundary_Cell3

